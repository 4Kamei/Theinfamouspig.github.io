<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GameTitle</title>
</head>
<body>
<style>
    #canvas{
        position: absolute;
        top: 0;
        left: 0;
    }
</style>
<canvas id="canvas"> </canvas>

<script src="packages/three.min.js"></script>
<script src="packages/perlin-noise-classic.js"></script>
<script>
    var     scene,
            clock,
            camera,
            renderer,
            mesh,
            mouse,
            mouseNorm,
            mouseDelta,
            canvasWidth = 0,
            canvasHeight = 0,
            radius = 300,
            zoom = 400,
            raycaster,
            particles,
            particleSystem,
            angle = 0,
            object = [],
            notTrue = true,
            toggle = [],
            pointerLock = false,
            state = "init0",
            colours = [],
            controls,
            time,
            movement,
            forward, backward, left, right,
            noise = PerlinNoise,
            canvas = document.getElementById("canvas");

    init();
    render();

    window.onload = window.onresize = function() {
        var     VPR = 0.95,   // canvas width to viewport width ratio
                viewportWidth = window.outerWidth,
                viewportHeight = window.outerHeight,
                canvas = document.getElementById("canvas");
        canvasWidth  = viewportWidth;
        canvasHeight = viewportHeight;
        renderer.setSize(canvasWidth, canvasHeight);

        camera.aspect = canvasWidth/canvasHeight;
        camera.updateProjectionMatrix();

        canvas.style.position = "fixed";
        canvas.setAttribute("width", canvasWidth);
        canvas.setAttribute("height", canvasHeight);

        mouse.x = 0;
        mouse.y = 0;
        mouseNorm.x = 0;
        mouseNorm.y = 0;
    };

    function init(){

        mouse = new THREE.Vector2();
        mouseNorm = new THREE.Vector2();
        mouseDelta = new THREE.Vector2(0, 0);
        raycaster = new THREE.Raycaster();
        renderer = new THREE.WebGLRenderer({canvas: canvas}, {antialias:true});

        var     WIDTH = canvas.clientWidth,
                HEIGHT = canvas.clientHeight;

        renderer.setSize(WIDTH, HEIGHT);
        clock = new THREE.Clock(true);

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(80, WIDTH / HEIGHT, 1, 40000);
        camera.position.z = 0;
        camera.position.y = 0;
        camera.position.x = -1;
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        camera.position.y = 10;
        camera.position.x = 0;
        camera._order = "YZX";
        camera.rotation.order = "YZX";
        var planeGeo = new THREE.PlaneGeometry( 2000, 2000 );
        var planeMat = new THREE.MeshBasicMaterial( {color: 0x33333333, side: THREE.DoubleSide} );


        var plane = new THREE.Mesh( planeGeo, planeMat );
        plane.rotation.x = Math.PI/2;
        //scene.add( plane );
        generateTerrain();
        console.log("Finished Generation");

        //scene.add(mesh)


        scene.add(camera);

        renderer.setClearColor(0x222222, 1);

        // Create a light, set its position, and add it to the scene.

        window.addEventListener('keydown', function(e){
            onKeyDown(e);
        });
        window.addEventListener('keyup', function(e){
            onKeyUp(e);
        });
        canvas.addEventListener('mousewheel', function(e){
            onScroll(e);
        });
        canvas.addEventListener('mousedown', function(e){
            onMouseDown(e);
        });

        canvas.addEventListener('mousemove', function(e){
            onMouseMove(e);
        });

        function onKeyDown(event){
            switch (event.keyCode){
                //w
                case 87 : forward  = true; break;
                //s
                case 83 : backward = true; break;
                //a
                case 65 : left = true; break;
                //d
                case 68 : right = true; break;
            }
        }
        function onKeyUp(event){
            switch (event.keyCode){
                //w
                case 87 : forward  = false; break;
                //s
                case 83 : backward = false; break;
                //a
                case 65 : left = false; break;
                //d
                case 68 : right = false; break;
            }
        }
        function onMouseMove(event) {
            event.preventDefault();
            if (pointerLock) {
                console.log(event.movementX + " : " + event.movementY);
                camera.rotation.y -= event.movementX/500;
                camera.rotation.x -= event.movementY/500
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                //camera.rotation.z += event.movementY/500;
            }else{
                mouseDelta.x = mouse.x - (event );
                mouseDelta.y = mouse.y - (event.clientY );
                mouse.x = event.clientX ;
                mouse.y = event.clientY ;
                mouseNorm.x = ((event.clientX ) / canvasWidth) * 2 - 1;
                mouseNorm.y = -((event.clientY ) / canvasHeight ) * 2 + 1;
            }
        }

        function onMouseDown(event){
            event.preventDefault();
            pointerLock ^= true;
            if(pointerLock){
                canvas.requestPointerLock = canvas.requestPointerLock ||
                        canvas.mozRequestPointerLock ||
                        canvas.webkitRequestPointerLock;
                canvas.requestPointerLock();
                controls.enabled = true
            }else{
                document.exitPointerLock = document.exitPointerLock    ||
                        document.mozExitPointerLock ||
                        document.webkitExitPointerLock;

                document.exitPointerLock();
            }
        }

        function onScroll(event){
            event.preventDefault();
            zoom += event.wheelDelta/-10;
        }
    }

    function generateTerrain(){
        var     particles = new THREE.Geometry(),
                pMaterial = new THREE.PointCloudMaterial({
                    transparent: true,
                    size: 2,
                    opacity: 0.7,
                    vertexColors: THREE.VertexColors
                });

        var lines = 300;
        var scale = 20;

        for(var x = -lines/2; x < lines/2; x++){
            scene.add(generateLine(x*scale, x*scale, -lines*scale/2, lines*scale/2, lines));
        }
        for(var z = -lines/2; z < lines/2; z++){
            scene.add(generateLine(-lines*scale/2, lines*scale/2, z*scale, z*scale, lines));
        }

        for(var i = -lines/2; i < lines/2; i++){
            for(var j = -lines/2; j < lines/2; j++){
                var point = generatePoint(i*scale, j*scale);
                particles.vertices.push(point);
                particles.colors = new THREE.Color().setHSL((Math.sin(point.y/200) + 1) * 0.5, + 0.6, 0.5, 0.5);
            }
        }

        var particleSystem = new THREE.PointCloud(particles, pMaterial);

        scene.add(particleSystem);


    }
    function getColor(y){
        if(y > 100){

        }
    }

    function generateLine(startX, endX, startZ, endZ, segments){
        var material = new THREE.LineBasicMaterial({
            linewidth: 2,
            vertexColors: THREE.VertexColors
        });

        var point;
        var lineGeometry = new THREE.Geometry;
        var i = 0;
        var col = [];

        function lineHelp(x, z){
            point = generatePoint(x, z);
            //console.log(noise.noise(Math.abs(startX +   zi*x), Math.abs(zi), 203) + " is the noise at " + startX +   zi*x +  " and " + zi);
            col[i] = new THREE.Color().setHSL((Math.sin(point.y/200) + 1) * 0.5, + 0.6, 0.5, 0.5);
            point.y;
            lineGeometry.vertices.push(point);
        }

        if(endX - startX != 0){
            var xIt = (endX - startX)/segments;
            var z =  (endZ - startZ)/(endX - startX);
            for(var xi = startX; xi != endX; xi += xIt, i++){
                lineHelp(xi, startZ +   z*xi);
            }
        }else{
            var zIt = (endZ - startZ)/segments;
            var x =  (endX - startX)/(endZ - startZ);
            for(var zi = startZ; zi != endZ; zi += zIt, i++){
                lineHelp(startX +   zi*x, zi);
            }
        }
        lineGeometry.colors = col;
        return new THREE.Line(lineGeometry, material);
    }
    function generatePoint(x, z){
        var yFunc = Math.abs(x*x * 0.0003 + 0.0003 * z*z);
        var noiseLevel = PerlinNoise.noise(x/20, z/20, 0.2);
        var y = 40 * yFunc * noiseLevel*noiseLevel/100 ;
        return new THREE.Vector3(x, y, z);
    }

    function sphericalToCartesian(radius, inclination, azimuthal) {
        var result = new THREE.Vector3();
        result.x = radius * Math.sin(inclination) * Math.cos(azimuthal);
        result.y = radius * Math.sin(inclination) * Math.sin(azimuthal);
        result.z = radius * Math.cos(inclination);
        return result;
    }

    function cartesianToCylindrical(coords){
        var radius = Math.sqrt(coords.x * coords.x + coords.y * coords.y);
        var azimuth = Math.atan(coords.y / coords.x);
        return [radius, azimuth, coords.z];
    }

    function cartesianToSpherical(coords){
        var x = coords.x;
        var y = coords.y;
        var z = coords.z;
        var rad = Math.sqrt(x*x + y*y +z*z);
        var inclination = Math.acos(z / Math.sqrt(x*x + y*y + z*z));
        var azimuth = Math.atan(y / x);
        return [rad, inclination, azimuth];
    }

    function sphericalToCylindrical(radius, inclination, azimuthal){
        radius = radius * Math.cos(inclination);
        var z = radius * Math.sin(inclination);
        return [radius, azimuthal, z];
    }

    function cylindricalToSpherical(radius, azimuthal, z){
        radius = Math.sqrt(radius*radius + azimuthal*azimuthal);
        var inclination = Math.atan(radius / z);
        return [radius, inclination, azimuthal];
    }

    function cylindricalToCartesian(radius, azimuthal, z){
        var x = radius * Math.cos(azimuthal);
        var y = radius * Math.sin(azimuthal);
        return new THREE.Vector3(x, y, z);
    }

    function update(){

    }

    function render() {
        // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
        requestAnimationFrame(render);
        //angle += 0.001;
        update();
        if(forward){
            camera.position.z -= Math.cos(camera.rotation.y);
            camera.position.x -= Math.sin(camera.rotation.y);
        }
        if(backward){
            camera.position.z += Math.cos(camera.rotation.y);
            camera.position.x += Math.sin(camera.rotation.y);
        }
        if(left){
            camera.position.z -= Math.cos(camera.rotation.y + Math.PI/2);
            camera.position.x -= Math.sin(camera.rotation.y + Math.PI/2);
        }
        if(right){
            camera.position.z -= Math.cos(camera.rotation.y - Math.PI/2);
            camera.position.x -= Math.sin(camera.rotation.y - Math.PI/2);
        }
        camera.position.y = generatePoint(camera.position.x, camera.position.z).y + 10;
        //camera.position.y = zoom;
        //controls.isOnObject( false );
        //raycaster.setFromCamera(mouse, camera);
        //var objects = raycaster.intersectObjects(scene.children);
        var vectorC = cylindricalToCartesian(zoom, angle, zoom/2);
        camera.rotation.pitch += 0.01;
        //for( var i = 0; i < objects.length; i++)
        //    objects[i].object.material.color.set(0xfffccc);				controls.update( Date.now() - time );


        //controls.update( Date.now() - time );

        renderer.render( scene, camera );
        //time = Date.now();
    }


</script>
</body>
</html>