<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <title>Kappa</title>
    <link  type="text/css" rel="stylesheet" href="js.css">
    <link  type="text/css" rel="stylesheet" href="style.css">

</head>

<body>
<header id="header">
    <div class="rectangle" id="topRect">
        <div id="spacer"> </div>
        <nav role='navigation'>
                    <span>
                        <a class="button" href="index.html"> Home </a>
                    </span>
                    <span>
                        <a class="buttonClicked">  Fancy Shit Right Here </a>
                    </span>
                    <span>
                        <a class="button" href="computing/bubbleSort.html"> Sorting Algorithms </a>
                    </span>
        </nav>
    </div>
</header>
    <canvas id="canvas">
        Woo tree.js
    </canvas>

        <script src="packages/three.min.js"></script>
        <script>
            var     scene,
                    camera,
                    renderer,
                    mesh,
                    mouse,
                    mouseNorm,
                    canvasLeft,
                    canvasTop,
                    canvasWidth = 0,
                    canvasHeight = 0,
                    radius = 300,
                    zoom = 900,
                    raycaster,
                    particles,
                    particleSystem,
                    angle = 0,
                    object = [],
                    notTrue = true,
                    toggle = [],
                    state = "init0",
                    canvas = document.getElementById("canvas");

            init();
            render();

            window.onload = window.onresize = function() {
                var     c2VP = 0.95,   // canvas width to viewport width ratio
                        cW2cH = 1,     // canvas width to canvas height ratio
                        viewportWidth = window.innerWidth,
                        viewportHeight = window.innerHeight,
                        canvas = document.getElementById("canvas");

                //Some error I made somewhere. This fixes it.
                c2VP *= cW2cH;

                viewportHeight = viewportHeight-69;
                //Make sure the thingy first in the width and height
                if(viewportWidth > viewportHeight)
                    canvasWidth = viewportHeight * c2VP;
                else
                    canvasWidth = viewportWidth * c2VP;

                canvasHeight = canvasWidth / cW2cH;

                renderer.setSize(canvasWidth, canvasHeight);

                camera.aspect = canvasWidth/canvasHeight;
                camera.updateProjectionMatrix();

                canvas.style.position = "fixed";
                canvas.setAttribute("width", canvasWidth);
                canvas.setAttribute("height", canvasHeight);

                canvasTop = (viewportHeight - canvasHeight) / 2 + 69;
                canvasLeft = (viewportWidth - canvasWidth) / 2;

                canvas.style.top = canvasTop + "px";
                canvas.style.left = canvasLeft + "px";

                mouse.x = 0;
                mouse.y = 0;
                mouseNorm.x = 0;
                mouseNorm.y = 0;

            };

            function init(){

                var ret = cartesianToSpherical(new THREE.Vector3(200, 200, 200));
                var cartCoords = sphericalToCartesian(ret[0], ret[1], ret[2]);
                console.log(cartCoords.x + " : " + cartCoords.y + " : " + cartCoords.z);

                mouse = new THREE.Vector2();
                mouseNorm = new THREE.Vector2();
                raycaster = new THREE.Raycaster();

                renderer = new THREE.WebGLRenderer({canvas: canvas}, {antialias:true});

                var     WIDTH = canvas.clientWidth,
                        HEIGHT = canvas.clientHeight;

                renderer.setSize(WIDTH, HEIGHT);

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(80, WIDTH / HEIGHT, 1, 4000);
                camera.position.z = zoom;
                camera.position.y = zoom/3;
                camera.position.x = zoom/3;
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                var planeGeo = new THREE.PlaneGeometry( 2000, 2000 );
                var planeMat = new THREE.MeshBasicMaterial( {color: 0x33333333, side: THREE.DoubleSide} );


                var plane = new THREE.Mesh( planeGeo, planeMat );
                plane.rotation.x = Math.PI/2;
                //scene.add( plane );

                particles = new THREE.Geometry;

                var pCount = 4000;
                toggle = Array.apply(null, new Array(pCount)).map(function(){ return true;});
                for (var p = 0; p < pCount; p++) {

                    var     rad = 1,
                            inclination,
                            azimuthal;

                    var     u = Math.random(),
                            v = Math.random();

                    azimuthal = Math.PI * 2 * u;
                    inclination = 0;

                    var coords = new THREE.Vector3(0, 0, 0);
                    var cylCoords = sphericalToCylindrical(rad, inclination, azimuthal);

                    var cylindrical= {
                        radius : cylCoords[0],
                        azimuthal : cylCoords[1],
                        z : cylCoords[2] + Math.random() * 10 -2
                    };

                    var spherical = {
                        radius: rad,
                        inclination: inclination,
                        azimuth: azimuthal
                    };

                    var particle = {
                        position: new THREE.Vector3(),
                        sphPosition: spherical,
                        cylPosition : cylindrical,
                        velocity: new THREE.Vector3(0, 0,  cylCoords[2] + Math.random() * 10)
                    };

                    particle.position = coords;

                    object.push(particle);

                    particles.vertices.push(particle.position);

                }

                console.log("Finished Generation");

                var material = new THREE.ParticleBasicMaterial({color: 0xff03f0},{size: 3});

                particleSystem = new THREE.ParticleSystem(particles, material);

                scene.add(particleSystem);


                //scene.add(mesh);
                scene.add(camera);


                renderer.setClearColor(0x222222, 1);

                // Create a light, set its position, and add it to the scene.




                canvas.addEventListener('mousewheel', function(e){
                    onScroll(e);
                });
                canvas.addEventListener('mousedown', function(e){
                    onMouseDown(e);
                });

                canvas.addEventListener('mousemove', function(e){
                    onMouseMove(e);
                });

                function onMouseMove(event){
                    event.preventDefault();
                    mouse.x = event.clientX - canvasLeft;
                    mouse.y = event.clientY - canvasTop;
                    mouseNorm.x = ((event.clientX - canvasLeft) / canvasWidth) * 2 - 1;
                    mouseNorm.y = - ((event.clientY - canvasTop ) / canvasHeight ) * 2 + 1;
                }

                function onMouseDown(event){
                    event.preventDefault();

                }

                function onScroll(event){
                    event.preventDefault();
                    zoom += event.wheelDelta/-10;
                }
            }

            function sphericalToCartesian(radius, inclination, azimuthal) {
                var result = new THREE.Vector3();
                result.x = radius * Math.sin(inclination) * Math.cos(azimuthal);
                result.y = radius * Math.sin(inclination) * Math.sin(azimuthal);
                result.z = radius * Math.cos(inclination);
                return result;
            }

            function cartesianToSpherical(coords){
                var x = coords.x;
                var y = coords.y;
                var z = coords.z;
                var rad = Math.sqrt(x*x + y*y +z*z);
                var inclination = Math.acos(z / Math.sqrt(x*x + y*y + z*z));
                var azimuth = Math.atan(y / x);
                return [rad, inclination, azimuth];
            }

            function sphericalToCylindrical(radius, inclination, azimuthal){
                radius = radius * Math.cos(inclination);
                azimuthal = azimuthal;
                var z = radius * Math.sin(inclination);
                return [radius, azimuthal, z];
            }

            function cylindricalToSpherical(radius, azimuthal, z){
                radius = Math.sqrt(radius*radius + azimuthal*azimuthal);
                var inclination = Math.atan(radius / z);
                return [radius, inclination, azimuthal];
            }

            function cylindricalToCartesian(radius, azimuthal, z){
                var x = radius * Math.cos(azimuthal);
                var y = radius * Math.sin(azimuthal);
                return new THREE.Vector3(x, y, z);
            }

            function update(){

                var count = object.length;

                while(count--){
                    var particle = object[count];
                    var cyl = particle.cylPosition;
                    var sph = particle.sphPosition;
                    var coords;
                    if(state == "init0"){
                        coords = cylindricalToCartesian(cyl.radius, cyl.azimuthal, cyl.z);
                        if(cyl.z < radius && cyl.z > -radius){
                            cyl.z += cyl.z/2.5;
                            if(cyl.z >= radius || cyl.z <= -radius){
                                if(object.every(function(element){return element.cylPosition.z >= radius || element.cylPosition.z <= -radius;})) {
                                    state = "init1";
                                }
                            }
                        }
                    }else if(state == "init1"){
                        cyl.azimuthal += 0.02;
                        cyl.radius += 300/radius;
                        coords = cylindricalToCartesian(cyl.radius, cyl.azimuthal, cyl.z);

                        var ct = object.length;
                        if(cyl.radius >= radius){
                            while (ct--) {
                                object[ct].sphPosition.radius = 300;
                                object[ct].cylPosition.radius = 300;
                                state = "init2";
                                var re = cylindricalToSpherical(300, object[ct].cylPosition.azimuthal, object[ct].cylPosition.z);
                                object[ct].sphPosition.inclination = re[1];
                                object[ct].sphPosition.azimuth = object[ct].cylPosition.azimuthal;
                            }
                        }
                    }else if(state == "init2"){
                        coords = cylindricalToCartesian(cyl.radius, cyl.azimuthal, cyl.z);
                        if(cyl.z > 1 || cyl.z < -1){
                           cyl.z -= cyl.z/10;
                        }else{

                        if(object.every(function(element){return element.cylPosition.z < 1 || element.cylPosition.z > -1;})){
                            var ct2 = object.length;
                            while (ct2--) {
                                object[ct2].sphPosition.radius = 300;
                                object[ct2].cylPosition.radius = 300;
                                state = "init3";

                                var re2 = cylindricalToSpherical(300, object[ct2].cylPosition.azimuthal, object[ct2].cylPosition.z);

                                object[ct2].sphPosition.inclination = re2[1];
                                object[ct2].sphPosition.azimuth = object[ct2].cylPosition.azimuthal;
                            }
                        }

                        }

                    }else if(state == "init3"){
                        sph.azimuth += 0.01;
                        sph.inclination += 0.03;
                        coords = sphericalToCartesian(sph.radius, sph.inclination, sph.azimuth);
                        if(sph.inclination >= Math.PI * 2 - 0.06){
                            cyl.radius = radius;
                            state = "init4";
                        }
                    }else if(state == "init4"){
                        coords = sphericalToCartesian(sph.radius, sph.inclination, sph.azimuth);
                        if(sph.radius > 4){
                            sph.radius -= sph.radius/10;
                        }else{
                            state = "mainGen";
                        }
                    }else if(state == "mainGen"){
                        var mainGenCount = object.length;
                        while(mainGenCount--){
                            var     rad = Math.random(),
                                    inclination,
                                    azimuthal;

                            var     u = Math.random(),
                                    v = Math.random();

                            azimuthal = Math.atan(2*u - 1);
                            inclination = Math.PI * 2 * v;

                            object[mainGenCount].sphPosition.radius = sph.radius = rad;
                            object[mainGenCount].sphPosition.azimuth = sph.azimuth = azimuthal;
                            object[mainGenCount].sphPosition.inclination = sph.inclination = inclination;
                            state = "main";
                        }
                    }else if(state == "main") {
                        if(sph.radius < radius){
                            sph.radius += sph.radius/10;
                            if(sph.radius >= radius){
                                sph.radius = radius;
                            }
                        }
                        sph.inclination += 0.01;
                        sph.azimuth += 0.01;
                        coords = sphericalToCartesian(sph.radius, sph.inclination, sph.azimuth);
                    }
                    particle.sphPosition = sph;
                    particle.cylPosition = cyl;
                    particle.position = coords;
                    particles.vertices[count] = particle.position;
                    particles.verticesNeedUpdate = true;
                }

            }

            function render() {
                // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
                requestAnimationFrame(render);

                update();
                angle += 0.01;
                //raycaster.setFromCamera(mouse, camera);
                //var objects = raycaster.intersectObjects(scene.children);
                camera.position.x += (mouseNorm.x * canvasWidth +400 - camera.position.x) * 0.1;
                camera.position.y += (mouseNorm.y * canvasHeight + 400 - camera.position.y) * 0.1;
                camera.position.z = zoom;
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                //for( var i = 0; i < objects.length; i++)
                //    objects[i].object.material.color.set(0xfffccc);
                renderer.render( scene, camera );
            }


        </script>
</body>
</html>
