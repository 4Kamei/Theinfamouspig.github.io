<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <title>Random Stuff</title>
    <link  type="text/css" rel="stylesheet" href="js.css">
    <link  type="text/css" rel="stylesheet" href="style.css">

</head>

<body>
<header id="header">
    <div class="rectangle" id="topRect">
        <div id="spacer"> </div>
        <nav role='navigation'>
                    <span>
                        <a class="button" href="index.html"> Home </a>
                    </span>
                    <span>
                        <a class="buttonClicked">  Fancy Shit Right Here </a>
                    </span>
                    <span>
                        <a class="button" href="computing/bubbleSort.html"> Sorting Algorithms </a>
                    </span>
        </nav>
    </div>
</header>
    <canvas id="canvas">
        Woo tree.js
    </canvas>

        <script src="packages/three.min.js"></script>
        <script src="packages/perlin-noise-classic.js"></script>
        <script src="packages/1d-noise.js"></script>
        <script>
            var     scene,
                    camera,
                    renderer,
                    mesh,
                    mouse,
                    mouseNorm,
                    mouseDelta,
                    canvasLeft,
                    canvasTop,
                    canvasWidth = 0,
                    canvasHeight = 0,
                    radius = 300,
                    zoom = 400,
                    raycaster,
                    particles,
                    particleSystem,
                    angle = 0,
                    object = [],
                    notTrue = true,
                    toggle = [],
                    pointerLock = false,
                    state = "init0",
                    colours = [],
                    noise = PerlinNoise,
                    canvas = document.getElementById("canvas");

            init();
            render();

            window.onload = window.onresize = function() {
                var     c2VP = 0.95,   // canvas width to viewport width ratio
                        cW2cH = 1,     // canvas width to canvas height ratio
                        viewportWidth = window.innerWidth,
                        viewportHeight = window.innerHeight,
                        canvas = document.getElementById("canvas");

                //Some error I made somewhere. This fixes it.
                c2VP *= cW2cH;

                viewportHeight = viewportHeight-69;
                //Make sure the thingy first in the width and height
                if(viewportWidth > viewportHeight)
                    canvasWidth = viewportHeight * c2VP;
                else
                    canvasWidth = viewportWidth * c2VP;

                canvasHeight = canvasWidth / cW2cH;

                renderer.setSize(canvasWidth, canvasHeight);

                camera.aspect = canvasWidth/canvasHeight;
                camera.updateProjectionMatrix();

                canvas.style.position = "fixed";
                canvas.setAttribute("width", canvasWidth);
                canvas.setAttribute("height", canvasHeight);

                canvasTop = (viewportHeight - canvasHeight) / 2 + 69;
                canvasLeft = (viewportWidth - canvasWidth) / 2;

                canvas.style.top = canvasTop + "px";
                canvas.style.left = canvasLeft + "px";

                mouse.x = 0;
                mouse.y = 0;
                mouseNorm.x = 0;
                mouseNorm.y = 0;


            };

            function init(){

                mouse = new THREE.Vector2();
                mouseNorm = new THREE.Vector2();
                mouseDelta = new THREE.Vector2(0, 0);
                raycaster = new THREE.Raycaster();
                console.log(Simple1DNoise.getVal(1));
                renderer = new THREE.WebGLRenderer({canvas: canvas}, {antialias:true});

                var     WIDTH = canvas.clientWidth,
                        HEIGHT = canvas.clientHeight;

                renderer.setSize(WIDTH, HEIGHT);

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(80, WIDTH / HEIGHT, 1, 40000);
                camera.position.z = 0;
                camera.position.y = 0;
                camera.position.x = -1;
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                camera.position.y = 10;
                camera.position.x = 0;

                var planeGeo = new THREE.PlaneGeometry( 2000, 2000 );
                var planeMat = new THREE.MeshBasicMaterial( {color: 0x33333333, side: THREE.DoubleSide} );


                var plane = new THREE.Mesh( planeGeo, planeMat );
                plane.rotation.x = Math.PI/2;
                //scene.add( plane );

                /*

                particles = new THREE.Geometry;

                var pCount = 10;
                for(var x = 0; x < pCount; x++){

                    var lineGeometryX = new THREE.Geometry();
                    var lineGeometryZ = new THREE.Geometry();

                    for(var z = 0; z < pCount; z++){

                        var coords = generatePoint(x, z, pCount/2, scale);

                        var cylindrical= {
                            radius : 0,
                            azimuthal : 0,
                            z : 0
                        };

                        var spherical = {
                            radius: 0,
                            inclination: 0,
                            azimuth: 0
                        };

                        var particle = {
                            position: new THREE.Vector3(),
                            sphPosition: spherical,
                            cylPosition : cylindrical,
                            velocity: new THREE.Vector3()
                        };


                        particle.position = coords;

                        var sphRes = cartesianToSpherical(coords);
                        particle.sphPosition.radius         = sphRes[0];
                        particle.sphPosition.inclination    = sphRes[1];
                        particle.sphPosition.azimuth        = sphRes[2];

                        var cylRes = cartesianToCylindrical(coords);

                        particle.cylPosition.radius         = cylRes[0];
                        particle.cylPosition.azimuthal      = cylRes[1];
                        particle.cylPosition.z              = cylRes[2];

                        particles.vertices.push(particle.position);

                        lineGeometryX.vertices.push(coords);
                        object.push(particle);

                        colours[object.length-1] = new THREE.Color();
                        colours[object.length-1] .setHSL(coords.y/100,0.5, 0.5);
                    }

                    lineGeometryX.colors = colours;
                    var lineX = new THREE.Line(lineGeometryX, lineMaterial);
                    var lineZ = new THREE.Line(lineGeometryZ, lineMaterial);
                    scene.add(lineX);
                    scene.add(lineZ);
                }

                particles.colors = colours;

                 var material = new THREE.PointCloudMaterial({
                 size: 4,
                 transparent: false,
                 opacity: 0.7,
                 vertexColors: THREE.VertexColors
                 });


                 particleSystem = new THREE.PointCloud(particles, material);
                 particleSystem.position = new THREE.Vector3(-pCount/2, 0, -pCount/2);

                 scene.add(particleSystem);

                */
                generateTerrain();
                console.log("Finished Generation");





                //scene.add(mesh);
                scene.add(camera);


                renderer.setClearColor(0x222222, 1);

                // Create a light, set its position, and add it to the scene.




                canvas.addEventListener('mousewheel', function(e){
                    onScroll(e);
                });
                canvas.addEventListener('mousedown', function(e){
                    onMouseDown(e);
                });

                canvas.addEventListener('mousemove', function(e){
                    onMouseMove(e);
                });

                function onMouseMove(event) {
                    if (pointerLock) {
                        console.log(event.movementX + " : " + event.movementY);
                        camera.rotation.y -= event.movementX/500;
                        //camera.rotation.z += event.movementY/500;
                    }else{
                        event.preventDefault();
                        mouseDelta.x = mouse.x - (event - canvasLeft);
                        mouseDelta.y = mouse.y - (event.clientY - canvasTop);
                        mouse.x = event.clientX - canvasLeft;
                        mouse.y = event.clientY - canvasTop;
                        mouseNorm.x = ((event.clientX - canvasLeft) / canvasWidth) * 2 - 1;
                        mouseNorm.y = -((event.clientY - canvasTop ) / canvasHeight ) * 2 + 1;
                        console.log(mouseDelta);
                    }
                }

                function onMouseDown(event){
                    event.preventDefault();
                    pointerLock ^= true;
                    if(pointerLock){
                        canvas.requestPointerLock = canvas.requestPointerLock ||
                                canvas.mozRequestPointerLock ||
                                canvas.webkitRequestPointerLock;

                        canvas.requestPointerLock()
                    }else{
                        document.exitPointerLock = document.exitPointerLock    ||
                                document.mozExitPointerLock ||
                                document.webkitExitPointerLock;

// Attempt to unlock
                        document.exitPointerLock();
                    }


                }

                function onScroll(event){
                    event.preventDefault();
                    zoom += event.wheelDelta/-10;
                }
            }

            function generateTerrain(){
                var lines = 600;
                var scale = 2;
                for(var x = -lines/2; x < lines/2; x++){
                    scene.add(generateLine(x*scale, x*scale, -lines*scale/2, lines*scale/2, lines));
                }
                for(var z = -lines/2; z < lines/2; z++){
                    scene.add(generateLine(-lines*scale/2, lines*scale/2, z*scale, z*scale, lines));
                }

            }

            function generateLine(startX, endX, startZ, endZ, segments){
                var material = new THREE.LineBasicMaterial({
                    linewidth: 2,
                    vertexColors: THREE.VertexColors
                });

                var point;
                var lineGeometry = new THREE.Geometry;
                var i = 0;
                var col = [];

                function lineHelp(x, z){
                    point = generatePoint(x, z);
                    //console.log(noise.noise(Math.abs(startX +   zi*x), Math.abs(zi), 203) + " is the noise at " + startX +   zi*x +  " and " + zi);
                    col[i] = new THREE.Color().setHSL(point.y/5 + 0.6, 0.5, 0.5);
                    point.y *= 40;
                    lineGeometry.vertices.push(point);
                }

                if(endX - startX != 0){
                    var xIt = (endX - startX)/segments;
                    var z =  (endZ - startZ)/(endX - startX);
                    for(var xi = startX; xi != endX; xi += xIt, i++){
                        lineHelp(xi, startZ +   z*xi);
                    }
                }else{
                    var zIt = (endZ - startZ)/segments;
                    var x =  (endX - startX)/(endZ - startZ);
                    for(var zi = startZ; zi != endZ; zi += zIt, i++){
                        lineHelp(startX +   zi*x, zi);
                    }
                }
                lineGeometry.colors = col;
                return new THREE.Line(lineGeometry, material);
            }
            function generatePoint(x, z){
                var distanceFromOrigin = Math.sqrt(x * x * 0.1 + z * z * 0.1);
                var noiseLevel = PerlinNoise.noise(x, z, 0.2);
                var y = distanceFromOrigin * noiseLevel * 1/100 ;
                return new THREE.Vector3(x, y, z);
            }

            function sphericalToCartesian(radius, inclination, azimuthal) {
                var result = new THREE.Vector3();
                result.x = radius * Math.sin(inclination) * Math.cos(azimuthal);
                result.y = radius * Math.sin(inclination) * Math.sin(azimuthal);
                result.z = radius * Math.cos(inclination);
                return result;
            }

            function cartesianToCylindrical(coords){
                var radius = Math.sqrt(coords.x * coords.x + coords.y * coords.y)
                var azimuth = Math.atan(coords.y / coords.x);
                return [radius, azimuth, coords.z];
            }

            function cartesianToSpherical(coords){
                var x = coords.x;
                var y = coords.y;
                var z = coords.z;
                var rad = Math.sqrt(x*x + y*y +z*z);
                var inclination = Math.acos(z / Math.sqrt(x*x + y*y + z*z));
                var azimuth = Math.atan(y / x);
                return [rad, inclination, azimuth];
            }

            function sphericalToCylindrical(radius, inclination, azimuthal){
                radius = radius * Math.cos(inclination);
                var z = radius * Math.sin(inclination);
                return [radius, azimuthal, z];
            }

            function cylindricalToSpherical(radius, azimuthal, z){
                radius = Math.sqrt(radius*radius + azimuthal*azimuthal);
                var inclination = Math.atan(radius / z);
                return [radius, inclination, azimuthal];
            }

            function cylindricalToCartesian(radius, azimuthal, z){
                var x = radius * Math.cos(azimuthal);
                var y = radius * Math.sin(azimuthal);
                return new THREE.Vector3(x, y, z);
            }

            function update(){

            }

            function render() {
                // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
                requestAnimationFrame(render);
                angle += 0.001;
                update();
                camera.position.y = zoom;
                //raycaster.setFromCamera(mouse, camera);
                //var objects = raycaster.intersectObjects(scene.children);
                var vectorC = cylindricalToCartesian(zoom, angle, zoom/2);
                //for( var i = 0; i < objects.length; i++)
                //    objects[i].object.material.color.set(0xfffccc);
                renderer.render( scene, camera );
            }


        </script>
</body>
</html>
